PROCEDURE Get_Top_Keywords_Weekly(in Begin_Time timestamp,
                                  in End_Time   timestamp)
LANGUAGE SQLSCRIPT AS
-------------------------------------------------------------------------------------
-- Procedure: Get_Top_Keywords_Weekly
-- Description: Retrieve daily totals of the top keywords over a period of time
-------------------------------------------------------------------------------------
BEGIN
   declare First_Day_Of_First_Week date;  -- Sunday of the first week
   declare Last_Day_Of_Last_Week date;    -- Sunday after Saturday of the last week
   declare Cur_Time timestamp;            -- Used to populate #results table

   First_Day_Of_First_Week = ADD_DAYS(:Begin_Time, (-1)*MOD((WEEKDAY(:Begin_Time)+1),7));
   Last_Day_Of_Last_Week = ADD_DAYS(:End_Time, MOD(12 - WEEKDAY(:End_Time), 7) + 1);

   -- Table to store the tokens and counts as well as generate a rank
   create local temporary table #token_rank(ta_token nvarchar(5000), cnt bigint, rank integer generated by default as identity not null);
   -- Table to store the results, one row for each top token in a given week for all weeks in the range
   create local temporary table #results(Begin_Time timestamp, End_Time timestamp, Rank integer, Token nvarchar(5000), Cnt Bigint);

   -- Retrieve all tokens and what day they occurred on in the range given
   week_query = select TA.pzinskey,
                       TA.ta_counter,
                       TA.ta_token,
                       TO_DATE(ADD_DAYS(R.pxcommitdatetime, (-1)*MOD((WEEKDAY(R.pxcommitdatetime)+1),7))) as Begin_Time,
                       TO_DATE(ADD_DAYS(R.pxcommitdatetime, MOD(12 - WEEKDAY(R.pxcommitdatetime), 7) + 1)) as End_Time,
                       R.pxcommitdatetime
                from "$TA_RDS_UEE_FD_DATA_REQUEST_EC.REQUESTTITLE" TA,
                     "RDS_UEE_FD_DATA_REQUEST_EC" R
                where TA.pzinskey = R.pzinskey
                  and R.pxcommitdatetime >= :First_Day_Of_First_Week and R.pxcommitdatetime < :Last_Day_Of_Last_Week
                union all
                select TA.pzinskey,
                       TA.ta_counter,
                       TA.ta_token,
                       TO_DATE(ADD_DAYS(R.pxcommitdatetime, (-1)*MOD((WEEKDAY(R.pxcommitdatetime)+1),7))) as Begin_Time,
                       TO_DATE(ADD_DAYS(R.pxcommitdatetime, MOD(12 - WEEKDAY(R.pxcommitdatetime), 7) + 1)) as End_Time,
                       R.pxcommitdatetime
                from "$TA_RDS_UEE_FD_DATA_REQUEST_EC.MISSIONDETAILS" TA,
                     "RDS_UEE_FD_DATA_REQUEST_EC" R
                where TA.pzinskey = R.pzinskey
                  and R.pxcommitdatetime >= :First_Day_Of_First_Week and R.pxcommitdatetime < :Last_Day_Of_Last_Week;

   -- Retrieve each token and count within the range given.  Used for ordering the final result set
   insert into #token_rank(ta_token, cnt)
   select ta_token, count(*) as cnt from (
                    select ta_token
                    from "$TA_RDS_UEE_FD_DATA_REQUEST_EC.REQUESTTITLE" TA,
                         "RDS_UEE_FD_DATA_REQUEST_EC" R
                    where TA.pzinskey = R.pzinskey
                      and R.pxcommitdatetime >= :First_Day_Of_First_Week and R.pxcommitdatetime < :Last_Day_Of_Last_Week
                    union all
                    select ta_token
                    from "$TA_RDS_UEE_FD_DATA_REQUEST_EC.MISSIONDETAILS" TA,
                         "RDS_UEE_FD_DATA_REQUEST_EC" R
                    where TA.pzinskey = R.pzinskey
                      and R.pxcommitdatetime >= :First_Day_Of_First_Week and R.pxcommitdatetime < :Last_Day_Of_Last_Week)
   group by ta_token order by cnt desc;

   -- Populate a temp table with all weeks in the range for top tokens with a Count of 0 for weeks have no occurrences of the token
   Cur_Time = :First_Day_Of_First_Week;
   while (:Cur_Time < :Last_Day_Of_Last_Week) do
      insert into #results(Begin_Time, End_Time, Rank, Token, Cnt)
         select top 10 :Cur_Time, ADD_NANO100(ADD_DAYS(:Cur_Time, 7), -1), Rank, TA_Token, 0 from #token_rank order by Rank;
      Cur_Time = ADD_DAYS(:Cur_Time, 7);
   end while;

   -- Select daily counts for each token
   result_query = select TO_TIMESTAMP(Begin_Time) as Begin_Time,
                         ADD_NANO100(End_Time, -1) as End_Time,
                         b.rank as Rank,
                         a.ta_token as Token,
                         count(*) as Cnt
                  from :week_query a,
                       #token_rank b
                  where a.ta_token = b.ta_token
                  group by b.rank, a.ta_token, b.cnt, Begin_Time, End_Time;
   -- Update temp table with the counts from each token for the given week
   update a set Cnt = b.Cnt from #results a, :result_query b where a.Begin_Time = b.Begin_time and a.Token = b.Token;

   --  Retrieve the final results set
   select Begin_Time, End_Time, Rank, Token, Cnt from #results;

   -- Clean up
   drop table #token_rank;
   drop table #results;
END
